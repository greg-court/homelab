locals {
  iface_vip = var.bootstrap ? { vip = { ip = "192.168.2.240" } } : {}
  iface_base = {
    interface   = "enp0s31f6"
    dhcp        = true
    vlans = [
      {
        vlanId      = 3,
        dhcp        = true,
      },
      {
        vlanId      = 4,
        dhcp        = true,
      }
    ]
  }
  base_patch = yamlencode({
    machine = {
      sysctls = { # leniency on multi-homed reverse path during bring-up
        "net.ipv4.conf.all.rp_filter"     = "2"
        "net.ipv4.conf.default.rp_filter" = "2"
      }
      nodeLabels = { "$patch" = "delete" } # ensures no 'node.kubernetes.io/exclude-from-external-load-balancers: ""' on control planes
      certSANs = [
        var.api_server, # additive, should not remove autogenerated SANs for each node hostname
      ]
      install = {
        # disk = var.install_disk
        disk = "/dev/disk/by-id/wwn-0x5001b448b45dbd16" # temp - dell laptop
        wipe = true
      }
      features = {
        kubePrism = { enabled = true, port = 7445 }
        hostDNS   = { enabled = true, forwardKubeDNSToHost = false }
      }
      network = {
        interfaces = [merge(local.iface_base, local.iface_vip)]
      }
      # network = {
      #   interfaces = [{
      #     interface = "bond0"
      #     dhcp      = true
      #     vip = {
      #       ip = "192.168.2.240"
      #     }
      #     bond = {
      #       mode           = "802.3ad"
      #       lacpRate       = "fast"
      #       xmitHashPolicy = "layer3+4"
      #       interfaces     = ["enp1s0", "enp2s0"] # putting NIC with DHCP reservation FIRST
      #     }
      #     vlans = [
      #       { vlanId = 3, dhcp = false, addresses = [] },
      #       { vlanId = 4, dhcp = false, addresses = [] }
      #     ]
      #   }]
      #   kubernetes = {
      #     virtualIP = {
      #       ip = "192.168.2.240"
      #     }
      #   }
      # }
    }
    cluster = {
      allowSchedulingOnControlPlanes = true
      network                        = { cni = { name = "none" } }
      proxy                          = { disabled = true }
      apiServer = {
        certSANs = [
          var.api_server,
        ]
        extraArgs = {
          "service-account-issuer" = "https://kubernetes.default.svc"
          "api-audiences"          = "https://kubernetes.default.svc"
        }
        admissionControl = [
          # as per https://www.talos.dev/v1.10/kubernetes-guides/network/deploying-cilium/
          # and https://www.talos.dev/v1.10/kubernetes-guides/configuration/pod-security/
          # to allow cilium to run tests
          {
            name = "PodSecurity"
            configuration = {
              apiVersion = "pod-security.admission.config.k8s.io/v1alpha1"
              kind       = "PodSecurityConfiguration"
              defaults = {
                enforce         = "baseline"
                enforce-version = "latest"
                audit           = "restricted"
                audit-version   = "latest"
                warn            = "restricted"
                warn-version    = "latest"
              }
              exemptions = {
                usernames      = []
                runtimeClasses = []
                namespaces     = ["cilium-test-1"]
              }
            }
          }
        ]
      }
    }
  })
  ephemeral_patch = yamlencode({
    apiVersion = "v1alpha1"
    kind       = "VolumeConfig"
    name       = "EPHEMERAL"
    provisioning = {
      diskSelector = { match = "system_disk" }
      maxSize      = "64GiB"
      grow         = false
    }
  })
  tmp_dir = "${path.module}/tmp"
}

resource "null_resource" "mkdir_tmp" {
  provisioner "local-exec" { command = "mkdir -p ${local.tmp_dir}" }
}

resource "talos_machine_secrets" "cluster" {}

data "talos_client_configuration" "client" {
  cluster_name         = var.cluster_name
  client_configuration = talos_machine_secrets.cluster.client_configuration
  nodes                = [var.bootstrap_node]
}

resource "azurerm_storage_blob" "talosconfig" {
  name                   = "${var.cluster_name}/talosconfig"
  storage_account_name   = var.storage_account_name
  storage_container_name = var.container_name
  type                   = "Block"
  content_type           = "text/plain"

  source_content = data.talos_client_configuration.client.talos_config
}

resource "local_file" "talosconfig_local" {
  filename = "${local.tmp_dir}/talosconfig"
  content  = data.talos_client_configuration.client.talos_config
}

data "talos_machine_configuration" "controlplane" {
  cluster_name     = var.cluster_name
  machine_type     = "controlplane"
  cluster_endpoint = var.cluster_endpoint
  machine_secrets  = talos_machine_secrets.cluster.machine_secrets
  config_patches   = [local.base_patch, local.ephemeral_patch]
}

resource "local_file" "controlplane_local" {
  depends_on = [null_resource.mkdir_tmp]
  filename   = "${local.tmp_dir}/controlplane.yaml"
  content    = data.talos_machine_configuration.controlplane.machine_configuration
}

# Apply machine config to all CP nodes BEFORE bootstrap
resource "talos_machine_configuration_apply" "controlplanes" {
  for_each = toset([
    "n1.klab.internal",
    # "n2.klab.internal",
    # "n3.klab.internal"
  ])

  # Hit EACH node’s Talos API directly (pre-bootstrap there’s no proxying)
  endpoint = each.value
  node     = each.value

  client_configuration        = talos_machine_secrets.cluster.client_configuration
  machine_configuration_input = data.talos_machine_configuration.controlplane.machine_configuration
  apply_mode                  = "auto"

  # make sure the rendered file/data exists first (not strictly required, but sane)
  depends_on = [local_file.controlplane_local]
}

# Bootstrap the cluster (Talos provider) — runs only when bootstrap=true
resource "talos_machine_bootstrap" "cluster" {
  count                = var.bootstrap ? 1 : 0
  node                 = var.bootstrap_node
  client_configuration = talos_machine_secrets.cluster.client_configuration
}

# Get kubeconfig after bootstrap
resource "talos_cluster_kubeconfig" "kc" {
  count                = var.bootstrap ? 1 : 0
  node                 = var.bootstrap_node
  client_configuration = talos_machine_secrets.cluster.client_configuration
  depends_on           = [talos_machine_bootstrap.cluster]
}

# Write kubeconfig locally (only when bootstrap=true)
resource "local_file" "kubeconfig_local" {
  count      = var.bootstrap ? 1 : 0
  depends_on = [null_resource.mkdir_tmp, talos_cluster_kubeconfig.kc]
  filename   = "${local.tmp_dir}/kubeconfig"
  content    = talos_cluster_kubeconfig.kc[0].kubeconfig_raw
}
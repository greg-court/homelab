apiVersion: v1
kind: ConfigMap
metadata:
  name: config-backups-scripts
  namespace: unifi
data:
  backup.sh: |
    #!/bin/sh
    set -eu

    : "${AZURE_SAS_URL?Missing AZURE_SAS_URL}"
    : "${PFSENSE_USER?Missing PFSENSE_USER}"
    : "${PFSENSE_PASS?Missing PFSENSE_PASS}"
    : "${TRUENAS_API_KEY?Missing TRUENAS_API_KEY}"
    # Optional: Discord webhook for notifications
    : "${DISCORD_WEBHOOK_URL:=}"

    PFSENSE_HOST="${PFSENSE_HOST:-192.168.2.1}" # swap to pfsense.internal when DNS is ready
    TRUENAS_HOST="${TRUENAS_HOST:-truenas.internal}"
    DATE="$(date -u +%Y%m%dT%H%M%SZ)"
    WORK="/work"
    mkdir -p "$WORK"

    # Keep N most recent per folder; defaults to 7
    RETAIN="${RETAIN:-7}"

    # Curl flags (optionally -k)
    CURL="curl -sS -L"
    [ "${CURL_INSECURE:-false}" = "true" ] && CURL="$CURL -k"

    # --- Discord helpers -------------------------------------------------------
    MSG=""  # we accumulate lines and send once on exit
    add() { MSG="${MSG}$*\n"; printf '%s\n' "$*"; }
    send_discord() {
      [ -n "${DISCORD_WEBHOOK_URL}" ] || return 0
      # Use form post so we don't need to JSON-escape newlines/quotes
      # Trim to 1900 chars to avoid Discord 2000-char limit
      SHORT_MSG="$(printf '%s' "$MSG" | awk 'BEGIN{max=1900} {s=s $0 "\n"} END{if (length(s)>max) print substr(s,1,max) "..."; else print s}')"
      ${CURL} -X POST -F "content=${SHORT_MSG}" "${DISCORD_WEBHOOK_URL}" >/dev/null 2>&1 || true
    }
    on_exit() {
      rc=$?
      STATUS="FAILURE"
      [ $rc -eq 0 ] && STATUS="SUCCESS"
      add "Status: ${STATUS}"
      send_discord
      exit $rc
    }
    trap on_exit EXIT

    add "Starting config-backups @ ${DATE}"
    add "Retain newest ${RETAIN} per folder"

    # --- pfSense config.xml ----------------------------------------------------
    COOK="$WORK/cookies.txt"; CSRF="$WORK/csrf.txt"
    rm -f "$COOK" "$CSRF"
    ${CURL} --cookie-jar "$COOK" "https://${PFSENSE_HOST}/diag_backup.php" \
      | grep -E "name=['\"]__csrf_magic['\"]" \
      | sed 's/.*value=["'\'']\([^"'\'' ]*\).*/\1/' > "$CSRF"

    ${CURL} --cookie "$COOK" --cookie-jar "$COOK" \
      --data-urlencode "login=Login" \
      --data-urlencode "usernamefld=${PFSENSE_USER}" \
      --data-urlencode "passwordfld=${PFSENSE_PASS}" \
      --data-urlencode "__csrf_magic=$(head -n1 "$CSRF")" \
      "https://${PFSENSE_HOST}/" > /dev/null

    ${CURL} --cookie "$COOK" --cookie-jar "$COOK" \
      "https://${PFSENSE_HOST}/diag_backup.php" \
      | grep -E "name=['\"]__csrf_magic['\"]" \
      | sed 's/.*value=["'\'']\([^"'\'' ]*\).*/\1/' > "$CSRF"

    PFS_OUT="${WORK}/pfsense-${DATE}.xml"
    ${CURL} --cookie "$COOK" --cookie-jar "$COOK" \
      --data-urlencode "download=download" \
      --data-urlencode "donotbackuprrd=yes" \
      --data-urlencode "__csrf_magic=$(head -n1 "$CSRF")" \
      "https://${PFSENSE_HOST}/diag_backup.php" > "$PFS_OUT"
    add "pfSense: $(basename "$PFS_OUT")"

    # --- TrueNAS config.db -----------------------------------------------------
    TRU_OUT="${WORK}/truenas-${DATE}.db"
    ${CURL} -H "Authorization: Bearer ${TRUENAS_API_KEY}" \
      -H "Accept: application/octet-stream" \
      -X POST "https://${TRUENAS_HOST}/api/v2.0/config/save" \
      --output "$TRU_OUT"
    add "TrueNAS: $(basename "$TRU_OUT")"

    # --- UniFi latest .unf from PVC -------------------------------------------
    UDIR="/unifi-data"
    UNF="$(find "$UDIR" -type f -name '*.unf' 2>/dev/null | xargs -r ls -t | head -n1 || true)"
    if [ -n "${UNF}" ]; then
      UNI_OUT="${WORK}/unifi-${DATE}.unf"
      cp "$UNF" "$UNI_OUT"
      add "UniFi: $(basename "$UNI_OUT")"
    else
      add "UniFi: (no .unf found)"
      UNI_OUT=""
    fi

    # --- Uploads to Azure Blob (SAS) ------------------------------------------
    BASE="${AZURE_SAS_URL%%\?*}"
    QS="${AZURE_SAS_URL#*\?}"

    upload() {
      FILE="$1"; FOLDER="$2"
      [ -n "$FILE" ] && [ -f "$FILE" ] || return 0
      NAME="$(basename "$FILE")"
      URL="${BASE}/${FOLDER}/${NAME}?${QS}"
      ${CURL} --fail-with-body -X PUT -T "$FILE" -H "x-ms-blob-type: BlockBlob" "$URL" >/dev/null
      add "Uploaded ${FOLDER}/${NAME}"
    }

    upload "$PFS_OUT"  "pfsense"
    upload "$TRU_OUT"  "truenas"
    [ -n "${UNI_OUT:-}" ] && upload "$UNI_OUT" "unifi"

    # --- Retention: keep newest $RETAIN per folder -----------------------------
    DELETED_PFS=0; DELETED_TRU=0; DELETED_UNI=0

    prune_folder() {
      FOLDER="$1"
      KEEP="${2:-$RETAIN}"
      KEYS="$(list_keys "$FOLDER")"
      COUNT="$(printf '%s\n' "$KEYS" | sed '/^$/d' | wc -l | awk '{print $1}')"

      if [ "$COUNT" -le "$KEEP" ]; then
        add "Retention: ${FOLDER}/ nothing to delete (<= ${KEEP})"
        return 0
      fi

      SORTED="$(printf '%s\n' "$KEYS" | sed '/^$/d' | LC_ALL=C sort -r)"
      OLD="$(printf '%s\n' "$SORTED" | tail -n +$((KEEP+1)) )"

      DEL_COUNT=0
      # run loop in *current* shell (no subshell), so counters stick
      while IFS= read -r KEY; do
        [ -n "$KEY" ] || continue
        DEL_URL="${BASE}/${KEY}?${QS}"
        ${CURL} --fail-with-body -X DELETE "$DEL_URL" >/dev/null
        echo "Deleted ${KEY}"
        DEL_COUNT=$((DEL_COUNT+1))
      done <<EOF
    $OLD
    EOF

      case "$FOLDER" in
        pfsense) DELETED_PFS=$((DELETED_PFS+DEL_COUNT));;
        truenas) DELETED_TRU=$((DELETED_TRU+DEL_COUNT));;
        unifi)   DELETED_UNI=$((DELETED_UNI+DEL_COUNT));;
      esac

      add "Retention: ${FOLDER}/ deleted ${DEL_COUNT}, kept ${KEEP} of ${COUNT}"
    }

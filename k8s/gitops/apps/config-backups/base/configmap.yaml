apiVersion: v1
kind: ConfigMap
metadata:
  name: config-backups-scripts
  namespace: unifi
data:
  backup.sh: |
    #!/bin/sh
    set -eu

    : "${AZURE_SAS_URL?Missing AZURE_SAS_URL}"
    : "${PFSENSE_USER?Missing PFSENSE_USER}"
    : "${PFSENSE_PASS?Missing PFSENSE_PASS}"
    : "${TRUENAS_API_KEY?Missing TRUENAS_API_KEY}"
    # Optional: Discord webhook for notifications
    : "${DISCORD_WEBHOOK_URL:=}"

    PFSENSE_HOST="${PFSENSE_HOST:-192.168.2.1}" # swap to pfsense.internal when DNS is ready
    TRUENAS_HOST="${TRUENAS_HOST:-truenas.internal}"
    DATE="$(date -u +%Y%m%dT%H%M%SZ)"
    WORK="/work"
    mkdir -p "$WORK"

    # Keep N most recent per folder; defaults to 7
    RETAIN="${RETAIN:-7}"

    # Curl flags (optionally -k)
    CURL="curl -sS -L"
    [ "${CURL_INSECURE:-false}" = "true" ] && CURL="$CURL -k"

    # --- Discord helpers -------------------------------------------------------
    MSG=""  # we accumulate lines and send once on exit
    add() { MSG="${MSG}$*\n"; printf '%s\n' "$*"; }

    # Escape a string for JSON (quotes, backslashes)
    json_escape() { printf '%s' "$1" | sed 's/\\/\\\\/g; s/"/\\"/g; s/\r//g'; }

    send_discord() {
      [ -n "${DISCORD_WEBHOOK_URL}" ] || return 0

      TITLE="Config Backups â€” ${STATUS:-UNKNOWN}"
      TS_ISO="$(date -u +%Y-%m-%dT%H:%M:%SZ)"
      [ "${STATUS:-SUCCESS}" = "SUCCESS" ] && COLOR=3066993 || COLOR=15158332

      BACKUPS="pfSense: ${PFS_BN}\nTrueNAS: ${TRU_BN}\nUniFi: ${UNI_BN:-none}"
      UPLOADS="pfsense/${PFS_BN}\ntruenas/${TRU_BN}\n${UNI_BN:+unifi/${UNI_BN}}"
      RETENTION="pfsense: ${RET_pfsense:-n/a}\ntruenas: ${RET_truenas:-n/a}\nunifi: ${RET_unifi:-n/a}"

      PAYLOAD="$(cat <<EOF
    {"username":"Config Backups","allowed_mentions":{"parse":[]},"embeds":[
      {"title":"$(json_escape "$TITLE")",
       "color":$COLOR,
       "timestamp":"$TS_ISO",
       "fields":[
         {"name":"Backups","value":"$(json_escape "$BACKUPS")","inline":false},
         {"name":"Uploads","value":"$(json_escape "$UPLOADS")","inline":false},
         {"name":"Retention","value":"$(json_escape "$RETENTION")","inline":false}
       ]}
    ]}
    EOF
    )"
      ${CURL} -H "Content-Type: application/json" -X POST -d "$PAYLOAD" "$DISCORD_WEBHOOK_URL" >/dev/null 2>&1 || true
    }

    on_exit() {
      rc=$?
      STATUS="FAILURE"
      [ $rc -eq 0 ] && STATUS="SUCCESS"
      add "Status: ${STATUS}"
      send_discord
      exit $rc
    }
    trap on_exit EXIT

    add "Starting config-backups @ ${DATE}"
    add "Retain newest ${RETAIN} per folder"

    # --- pfSense config.xml ----------------------------------------------------
    COOK="$WORK/cookies.txt"; CSRF="$WORK/csrf.txt"
    rm -f "$COOK" "$CSRF"
    ${CURL} --cookie-jar "$COOK" "https://${PFSENSE_HOST}/diag_backup.php" \
      | grep -E "name=['\"]__csrf_magic['\"]" \
      | sed 's/.*value=["'\'']\([^"'\'' ]*\).*/\1/' > "$CSRF"

    ${CURL} --cookie "$COOK" --cookie-jar "$COOK" \
      --data-urlencode "login=Login" \
      --data-urlencode "usernamefld=${PFSENSE_USER}" \
      --data-urlencode "passwordfld=${PFSENSE_PASS}" \
      --data-urlencode "__csrf_magic=$(head -n1 "$CSRF")" \
      "https://${PFSENSE_HOST}/" > /dev/null

    ${CURL} --cookie "$COOK" --cookie-jar "$COOK" \
      "https://${PFSENSE_HOST}/diag_backup.php" \
      | grep -E "name=['\"]__csrf_magic['\"]" \
      | sed 's/.*value=["'\'']\([^"'\'' ]*\).*/\1/' > "$CSRF"

    PFS_OUT="${WORK}/pfsense-${DATE}.xml"
    ${CURL} --cookie "$COOK" --cookie-jar "$COOK" \
      --data-urlencode "download=download" \
      --data-urlencode "donotbackuprrd=yes" \
      --data-urlencode "__csrf_magic=$(head -n1 "$CSRF")" \
      "https://${PFSENSE_HOST}/diag_backup.php" > "$PFS_OUT"
    add "pfSense: $(basename "$PFS_OUT")"
    PFS_BN="$(basename "$PFS_OUT")"

    # --- TrueNAS config.db -----------------------------------------------------
    TRU_OUT="${WORK}/truenas-${DATE}.db"
    ${CURL} -H "Authorization: Bearer ${TRUENAS_API_KEY}" \
      -H "Accept: application/octet-stream" \
      -X POST "https://${TRUENAS_HOST}/api/v2.0/config/save" \
      --output "$TRU_OUT"
    add "TrueNAS: $(basename "$TRU_OUT")"
    TRU_BN="$(basename "$TRU_OUT")"

    # --- UniFi latest .unf from PVC -------------------------------------------
    UDIR="/unifi-data"
    UNF="$(find "$UDIR" -type f -name '*.unf' 2>/dev/null | xargs -r ls -t | head -n1 || true)"
    if [ -n "${UNF}" ]; then
      UNI_OUT="${WORK}/unifi-${DATE}.unf"
      cp "$UNF" "$UNI_OUT"
      add "UniFi: $(basename "$UNI_OUT")"
      UNI_BN="$(basename "$UNI_OUT")"
    else
      add "UniFi: (no .unf found)"
      UNI_OUT=""
      UNI_BN=""
    fi

    # --- Uploads to Azure Blob (SAS) ------------------------------------------
    BASE="${AZURE_SAS_URL%%\?*}"
    QS="${AZURE_SAS_URL#*\?}"

    upload() {
      FILE="$1"; FOLDER="$2"
      [ -n "$FILE" ] && [ -f "$FILE" ] || return 0
      NAME="$(basename "$FILE")"
      URL="${BASE}/${FOLDER}/${NAME}?${QS}"
      ${CURL} --fail-with-body -X PUT -T "$FILE" -H "x-ms-blob-type: BlockBlob" "$URL" >/dev/null
      add "Uploaded ${FOLDER}/${NAME}"
    }

    upload "$PFS_OUT"  "pfsense"
    upload "$TRU_OUT"  "truenas"
    [ -n "${UNI_OUT:-}" ] && upload "$UNI_OUT" "unifi"

    # --- Retention: keep newest $RETAIN per folder -----------------------------
    DELETED_PFS=0; DELETED_TRU=0; DELETED_UNI=0

    # List all blob keys under a folder (handles one-line XML + pagination)
    list_keys() {
      FOLDER="$1"
      MARKER=""
      OUT=""
      while :; do
        URL="${BASE}?${QS}&restype=container&comp=list&prefix=${FOLDER}/&maxresults=5000${MARKER:+&marker=$MARKER}"
        RESP="$(${CURL} --fail-with-body "$URL")" || { echo "$RESP" >&2; return 1; }

        NAMES="$(printf '%s' "$RESP" \
          | tr -d '\n' \
          | sed 's#<Name>#\n<Name>#g' \
          | sed -n 's:.*<Name>\([^<]*\)</Name>.*:\1:p' \
          | grep "^${FOLDER}/" || true)"
        [ -n "$NAMES" ] && OUT="${OUT}${OUT:+\n}${NAMES}"

        MARKER="$(printf '%s' "$RESP" \
          | tr -d '\n' \
          | sed -n 's:.*<NextMarker>\([^<]*\)</NextMarker>.*:\1:p')"
        [ -z "$MARKER" ] && break
      done
      printf '%s\n' "$OUT"
    }

    prune_folder() {
      FOLDER="$1"
      KEEP="${2:-$RETAIN}"
      KEYS="$(list_keys "$FOLDER")"
      COUNT="$(printf '%s\n' "$KEYS" | sed '/^$/d' | wc -l | awk '{print $1}')"

      if [ "$COUNT" -le "$KEEP" ]; then
        add "Retention: ${FOLDER}/ nothing to delete (<= ${KEEP})"
        eval "RET_${FOLDER}=\"kept ${COUNT} of ${COUNT}\""
        return 0
      fi

      SORTED="$(printf '%s\n' "$KEYS" | sed '/^$/d' | LC_ALL=C sort -r)"
      OLD="$(printf '%s\n' "$SORTED" | tail -n +$((KEEP+1)) )"

      DEL_COUNT=0
      OLD_KEYS="$WORK/${FOLDER}-old.txt"
      printf '%s\n' "$OLD" > "$OLD_KEYS"

      while IFS= read -r KEY; do
        [ -n "$KEY" ] || continue
        DEL_URL="${BASE}/${KEY}?${QS}"
        ${CURL} --fail-with-body -X DELETE "$DEL_URL" >/dev/null
        echo "Deleted ${KEY}"
        DEL_COUNT=$((DEL_COUNT+1))
      done < "$OLD_KEYS"

      rm -f "$OLD_KEYS"

      case "$FOLDER" in
        pfsense) DELETED_PFS=$((DELETED_PFS+DEL_COUNT));;
        truenas) DELETED_TRU=$((DELETED_TRU+DEL_COUNT));;
        unifi)   DELETED_UNI=$((DELETED_UNI+DEL_COUNT));;
      esac

      eval "RET_${FOLDER}=\"deleted ${DEL_COUNT}, kept ${KEEP} of ${COUNT}\""
      add "Retention: ${FOLDER}/ deleted ${DEL_COUNT}, kept ${KEEP} of ${COUNT}"
    }

    prune_folder "pfsense"  "$RETAIN"
    prune_folder "truenas"  "$RETAIN"
    prune_folder "unifi"    "$RETAIN"
    add "Pruned totals -> pfsense:${DELETED_PFS} truenas:${DELETED_TRU} unifi:${DELETED_UNI}"

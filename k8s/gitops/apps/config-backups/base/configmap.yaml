apiVersion: v1
kind: ConfigMap
metadata:
  name: config-backups-scripts
  namespace: unifi
data:
  backup.sh: |
    #!/bin/sh
    set -eu

    : "${AZURE_SAS_URL?Missing AZURE_SAS_URL}"
    : "${PFSENSE_USER?Missing PFSENSE_USER}"
    : "${PFSENSE_PASS?Missing PFSENSE_PASS}"
    : "${TRUENAS_API_KEY?Missing TRUENAS_API_KEY}"

    PFSENSE_HOST="${PFSENSE_HOST:-192.168.2.1}" # replace with pfsense.internal when configured vlan-scoped dns
    TRUENAS_HOST="${TRUENAS_HOST:-truenas.internal}"
    DATE="$(date -u +%Y%m%dT%H%M%SZ)"
    WORK="/work"
    mkdir -p "$WORK"

    # Keep N most recent per folder; defaults to 7
    RETAIN="${RETAIN:-7}"

    # Curl flags (optionally -k)
    CURL="curl -sS -L"
    [ "${CURL_INSECURE:-false}" = "true" ] && CURL="$CURL -k"

    # ---------- pfSense config.xml ----------
    # 1) Fetch CSRF from backup page (unauth), 2) login, 3) re-fetch CSRF, 4) post download
    COOK="$WORK/cookies.txt"; CSRF="$WORK/csrf.txt"
    rm -f "$COOK" "$CSRF"
    $CURL --cookie-jar "$COOK" "https://${PFSENSE_HOST}/diag_backup.php" \
      | grep -E "name=['\"]__csrf_magic['\"]" \
      | sed 's/.*value=["'\'']\([^"'\'' ]*\).*/\1/' > "$CSRF"

    $CURL --cookie "$COOK" --cookie-jar "$COOK" \
      --data-urlencode "login=Login" \
      --data-urlencode "usernamefld=${PFSENSE_USER}" \
      --data-urlencode "passwordfld=${PFSENSE_PASS}" \
      --data-urlencode "__csrf_magic=$(head -n1 "$CSRF")" \
      "https://${PFSENSE_HOST}/" > /dev/null

    $CURL --cookie "$COOK" --cookie-jar "$COOK" \
      "https://${PFSENSE_HOST}/diag_backup.php" \
      | grep -E "name=['\"]__csrf_magic['\"]" \
      | sed 's/.*value=["'\'']\([^"'\'' ]*\).*/\1/' > "$CSRF"

    PFS_OUT="${WORK}/pfsense-${DATE}.xml"
    $CURL --cookie "$COOK" --cookie-jar "$COOK" \
      --data-urlencode "download=download" \
      --data-urlencode "donotbackuprrd=yes" \
      --data-urlencode "__csrf_magic=$(head -n1 "$CSRF")" \
      "https://${PFSENSE_HOST}/diag_backup.php" > "$PFS_OUT"

    # ---------- TrueNAS config.db ----------
    TRU_OUT="${WORK}/truenas-${DATE}.db"
    $CURL -H "Authorization: Bearer ${TRUENAS_API_KEY}" \
      -H "Accept: application/octet-stream" \
      -X POST "https://${TRUENAS_HOST}/api/v2.0/config/save" \
      --output "$TRU_OUT"

    # ---------- UniFi latest .unf from PVC ----------
    UDIR="/unifi-data"
    UNF="$(find "$UDIR" -type f -name '*.unf' 2>/dev/null | xargs -r ls -t | head -n1 || true)"
    if [ -n "${UNF}" ]; then
      UNI_OUT="${WORK}/unifi-${DATE}.unf"
      cp "$UNF" "$UNI_OUT"
    else
      echo "WARN: no UniFi .unf found under $UDIR" >&2
      UNI_OUT=""
    fi

    # ---------- Uploads to Azure Blob (SAS) ----------
    # AZURE_SAS_URL is like: https://acct.blob.core.windows.net/<container>?<sas>
    BASE="${AZURE_SAS_URL%%\?*}"
    QS="${AZURE_SAS_URL#*\?}"

    upload() {
      FILE="$1"; FOLDER="$2"
      [ -n "$FILE" ] && [ -f "$FILE" ] || return 0
      NAME="$(basename "$FILE")"
      URL="${BASE}/${FOLDER}/${NAME}?${QS}"
      # --fail-with-body is nice to surface 4xx/5xx; keep KISS if you want
      $CURL --fail-with-body -X PUT -T "$FILE" -H "x-ms-blob-type: BlockBlob" "$URL"
      echo "Uploaded ${FOLDER}/${NAME}"
    }

    upload "$PFS_OUT"  "pfsense"
    upload "$TRU_OUT"  "truenas"
    [ -n "${UNI_OUT:-}" ] && upload "$UNI_OUT" "unifi"

    # ---------- Retention: keep newest $RETAIN per folder ----------
    # NOTE: Requires SAS with 'l' (list) and 'd' (delete) permissions.
    # List all blob keys under a folder (robust to 1-line XML + pagination)
    list_keys() {
      FOLDER="$1"
      MARKER=""
      OUT=""

      while :; do
        URL="${BASE}?${QS}&restype=container&comp=list&prefix=${FOLDER}/&maxresults=5000${MARKER:+&marker=$MARKER}"
        RESP="$($CURL --fail-with-body "$URL")" || { echo "$RESP" >&2; return 1; }

        # Extract every <Name>â€¦</Name> occurrence from a single long line
        NAMES="$(printf '%s' "$RESP" | awk '{
          s=$0;
          while (match(s, /<Name>([^<]+)<\/Name>/, a)) { print a[1]; s=substr(s, RSTART+RLENGTH); }
        }' | grep "^${FOLDER}/" || true)"

        [ -n "$NAMES" ] && OUT="${OUT}${OUT:+\n}${NAMES}"

        # Grab NextMarker (empty when done)
        MARKER="$(printf '%s' "$RESP" | awk 'match($0, /<NextMarker>([^<]*)<\/NextMarker>/, m){print m[1]}')"
        [ -z "$MARKER" ] && break
      done

      printf '%s\n' "$OUT"
    }

    prune_folder() {
      FOLDER="$1"
      KEEP="${2:-$RETAIN}"
      KEYS="$(list_keys "$FOLDER")"
      COUNT="$(printf '%s\n' "$KEYS" | sed '/^$/d' | wc -l | awk "{print \$1}")"

      if [ "$COUNT" -le "$KEEP" ]; then
        echo "Nothing to delete under ${FOLDER}/ (<= ${KEEP})."
        return 0
      fi

      # Newest first by filename (timestamp timestamps sort lexicographically)
      SORTED="$(printf '%s\n' "$KEYS" | sed '/^$/d' | LC_ALL=C sort -r)"
      OLD="$(printf '%s\n' "$SORTED" | tail -n +$((KEEP+1)) )"

      printf '%s\n' "$OLD" | while IFS= read -r KEY; do
        [ -n "$KEY" ] || continue
        DEL_URL="${BASE}/${KEY}?${QS}"
        $CURL --fail-with-body -X DELETE "$DEL_URL"
        echo "Deleted ${KEY}"
      done
    }

    prune_folder "pfsense"  "$RETAIN"
    prune_folder "truenas"  "$RETAIN"
    prune_folder "unifi"    "$RETAIN"

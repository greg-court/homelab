apiVersion: v1
kind: ConfigMap
metadata:
  name: config-backups-scripts
  namespace: unifi
data:
  backup.sh: |
    #!/bin/sh
    set -eu

    : "${AZURE_SAS_URL?Missing AZURE_SAS_URL}"
    : "${PFSENSE_USER?Missing PFSENSE_USER}"
    : "${PFSENSE_PASS?Missing PFSENSE_PASS}"
    : "${TRUENAS_API_KEY?Missing TRUENAS_API_KEY}"
    : "${DISCORD_WEBHOOK_URL:=}"   # optional

    PFSENSE_HOST="${PFSENSE_HOST:-192.168.2.1}" # swap to pfsense.internal when DNS is ready
    TRUENAS_HOST="${TRUENAS_HOST:-truenas.internal}"
    DATE="$(date -u +%Y%m%dT%H%M%SZ)"
    WORK="/work"
    mkdir -p "$WORK"

    # Keep N most recent per folder; defaults to 7
    RETAIN="${RETAIN:-7}"

    # Curl flags (optionally -k)
    CURL="curl -sS -L"
    [ "${CURL_INSECURE:-false}" = "true" ] && CURL="$CURL -k"

    # ---------- tiny log helpers ----------
    MSG=""  # accumulate lines -> Discord once on exit
    add() { MSG="${MSG}$*\n"; printf '%s\n' "$*"; }
    fail() { add "ERROR!!! $*"; exit 1; }

    # Escape for JSON and make *real* newlines into \n (not \\n)
    json_escape_ml() {
      # 1) escape backslashes + quotes, 2) turn newlines into \n
      sed -e 's/\\/\\\\/g' -e 's/"/\\"/g' -e 's/\r//g' | awk '{printf "%s\\n",$0}' | sed '$ s/\\n$//'
    }

    send_discord() {
      [ -n "${DISCORD_WEBHOOK_URL}" ] || return 0

      TITLE="Config Backups â€” ${STATUS:-UNKNOWN}"
      TS_ISO="$(date -u +%Y-%m-%dT%H:%M:%SZ)"
      [ "${STATUS:-SUCCESS}" = "SUCCESS" ] && COLOR=3066993 || COLOR=15158332

      # Build multiline field values with *real newlines*
      BACKUPS="$(printf 'pfSense: %s\nTrueNAS: %s\nUniFi: %s' "${PFS_BN:-none}" "${TRU_BN:-none}" "${UNI_BN:-none}")"
      UPLOADS="$(printf 'pfsense/%s\ntruenas/%s\n%s' "${PFS_BN:-none}" "${TRU_BN:-none}" "${UNI_BN:+unifi/${UNI_BN}}")"
      [ -z "${UNI_BN:-}" ] && UPLOADS="$(printf 'pfsense/%s\ntruenas/%s' "${PFS_BN:-none}" "${TRU_BN:-none}")"
      RETENTION="$(printf 'pfsense: %s\ntruenas: %s\nunifi: %s' "${RET_pfsense:-n/a}" "${RET_truenas:-n/a}" "${RET_unifi:-n/a}")"

      PAYLOAD="$(cat <<EOF
    {"username":"Config Backups","allowed_mentions":{"parse":[]},"embeds":[
      {"title":"$(printf '%s' "$TITLE" | json_escape_ml)",
       "color":$COLOR,
       "timestamp":"$TS_ISO",
       "fields":[
         {"name":"Backups","value":"$(printf '%s' "$BACKUPS" | json_escape_ml)","inline":false},
         {"name":"Uploads","value":"$(printf '%s' "$UPLOADS" | json_escape_ml)","inline":false},
         {"name":"Retention","value":"$(printf '%s' "$RETENTION" | json_escape_ml)","inline":false}
       ]}
    ]}
    EOF
    )"
      ${CURL} -H "Content-Type: application/json" -X POST -d "$PAYLOAD" "$DISCORD_WEBHOOK_URL" >/dev/null 2>&1 || true
    }

    on_exit() {
      rc=$?
      STATUS="FAILURE"
      [ $rc -eq 0 ] && STATUS="SUCCESS"
      add "Status: ${STATUS}"
      send_discord
      exit $rc
    }
    trap on_exit EXIT

    add "Starting config-backups @ ${DATE}"
    add "Retain newest ${RETAIN} per folder"

    # --- pfSense config.xml ----------------------------------------------------
    COOK="$WORK/cookies.txt"; CSRF="$WORK/csrf.txt"
    rm -f "$COOK" "$CSRF"
    ${CURL} --cookie-jar "$COOK" "https://${PFSENSE_HOST}/diag_backup.php" \
      | grep -E "name=['\"]__csrf_magic['\"]" \
      | sed 's/.*value=["'\'']\([^"'\'' ]*\).*/\1/' > "$CSRF" \
      || fail "pfSense: could not fetch CSRF token"

    ${CURL} --cookie "$COOK" --cookie-jar "$COOK" \
      --data-urlencode "login=Login" \
      --data-urlencode "usernamefld=${PFSENSE_USER}" \
      --data-urlencode "passwordfld=${PFSENSE_PASS}" \
      --data-urlencode "__csrf_magic=$(head -n1 "$CSRF")" \
      "https://${PFSENSE_HOST}/" > /dev/null \
      || fail "pfSense: login failed"

    ${CURL} --cookie "$COOK" --cookie-jar "$COOK" \
      "https://${PFSENSE_HOST}/diag_backup.php" \
      | grep -E "name=['\"]__csrf_magic['\"]" \
      | sed 's/.*value=["'\'']\([^"'\'' ]*\).*/\1/' > "$CSRF" \
      || fail "pfSense: CSRF refresh failed"

    PFS_OUT="${WORK}/pfsense-${DATE}.xml"
    ${CURL} --cookie "$COOK" --cookie-jar "$COOK" \
      --data-urlencode "download=download" \
      --data-urlencode "donotbackuprrd=yes" \
      --data-urlencode "__csrf_magic=$(head -n1 "$CSRF")" \
      "https://${PFSENSE_HOST}/diag_backup.php" > "$PFS_OUT" \
      || fail "pfSense: config download failed"
    PFS_BN="$(basename "$PFS_OUT")"
    add "pfSense: ${PFS_BN}"

    # --- TrueNAS config.db -----------------------------------------------------
    TRU_OUT="${WORK}/truenas-${DATE}.db"
    ${CURL} -H "Authorization: Bearer ${TRUENAS_API_KEY}" \
      -H "Accept: application/octet-stream" \
      -X POST "https://${TRUENAS_HOST}/api/v2.0/config/save" \
      --output "$TRU_OUT" \
      || fail "TrueNAS: config save/download failed"
    TRU_BN="$(basename "$TRU_OUT")"
    add "TrueNAS: ${TRU_BN}"

    # --- UniFi latest .unf from PVC -------------------------------------------
    UDIR="/unifi-data"
    UNF="$(find "$UDIR" -type f -name '*.unf' 2>/dev/null | xargs -r ls -t | head -n1 || true)"
    if [ -n "${UNF}" ]; then
      UNI_OUT="${WORK}/unifi-${DATE}.unf"
      cp "$UNF" "$UNI_OUT" || fail "UniFi: copy .unf failed"
      UNI_BN="$(basename "$UNI_OUT")"
      add "UniFi: ${UNI_BN}"
    else
      UNI_OUT=""
      UNI_BN=""
      add "UniFi: (no .unf found)"
    fi

    # --- Uploads to Azure Blob (SAS) ------------------------------------------
    BASE="${AZURE_SAS_URL%%\?*}"
    QS="${AZURE_SAS_URL#*\?}"

    upload() {
      FILE="$1"; FOLDER="$2"
      [ -n "$FILE" ] && [ -f "$FILE" ] || return 0
      NAME="$(basename "$FILE")"
      URL="${BASE}/${FOLDER}/${NAME}?${QS}"
      ${CURL} --fail-with-body -X PUT -T "$FILE" -H "x-ms-blob-type: BlockBlob" "$URL" >/dev/null \
        || fail "Azure: upload failed for ${FOLDER}/${NAME}"
      add "Uploaded ${FOLDER}/${NAME}"
    }

    upload "$PFS_OUT"  "pfsense"
    upload "$TRU_OUT"  "truenas"
    [ -n "${UNI_OUT:-}" ] && upload "$UNI_OUT" "unifi"

    # --- Retention: keep newest $RETAIN per folder -----------------------------
    DELETED_PFS=0; DELETED_TRU=0; DELETED_UNI=0

    # List all blob keys under a folder (handles one-line XML + pagination)
    list_keys() {
      FOLDER="$1"
      MARKER=""
      OUT=""
      while :; do
        URL="${BASE}?${QS}&restype=container&comp=list&prefix=${FOLDER}/&maxresults=5000${MARKER:+&marker=$MARKER}"
        RESP="$(${CURL} --fail-with-body "$URL")" || fail "Azure: list failed for ${FOLDER}/"
        NAMES="$(printf '%s' "$RESP" \
          | tr -d '\n' \
          | sed 's#<Name>#\n<Name>#g' \
          | sed -n 's:.*<Name>\([^<]*\)</Name>.*:\1:p' \
          | grep "^${FOLDER}/" || true)"
        [ -n "$NAMES" ] && OUT="${OUT}${OUT:+\n}${NAMES}"
        MARKER="$(printf '%s' "$RESP" \
          | tr -d '\n' \
          | sed -n 's:.*<NextMarker>\([^<]*\)</NextMarker>.*:\1:p')"
        [ -z "$MARKER" ] && break
      done
      printf '%s\n' "$OUT"
    }

    prune_folder() {
      FOLDER="$1"
      KEEP="${2:-$RETAIN}"
      KEYS="$(list_keys "$FOLDER")"
      COUNT="$(printf '%s\n' "$KEYS" | sed '/^$/d' | wc -l | awk '{print $1}')"

      if [ "$COUNT" -le "$KEEP" ]; then
        eval "RET_${FOLDER}=\"kept ${COUNT} of ${COUNT}\""
        add "Retention: ${FOLDER}/ nothing to delete (<= ${KEEP})"
        return 0
      fi

      SORTED="$(printf '%s\n' "$KEYS" | sed '/^$/d' | LC_ALL=C sort -r)"
      OLD="$(printf '%s\n' "$SORTED" | tail -n +$((KEEP+1)) )"

      DEL_COUNT=0
      OLD_KEYS="$WORK/${FOLDER}-old.txt"
      printf '%s\n' "$OLD" > "$OLD_KEYS"

      while IFS= read -r KEY; do
        [ -n "$KEY" ] || continue
        DEL_URL="${BASE}/${KEY}?${QS}"
        ${CURL} --fail-with-body -X DELETE "$DEL_URL" >/dev/null \
          || fail "Azure: delete failed for ${KEY}"
        echo "Deleted ${KEY}"
        DEL_COUNT=$((DEL_COUNT+1))
      done < "$OLD_KEYS"

      rm -f "$OLD_KEYS"

      case "$FOLDER" in
        pfsense) DELETED_PFS=$((DELETED_PFS+DEL_COUNT));;
        truenas) DELETED_TRU=$((DELETED_TRU+DEL_COUNT));;
        unifi)   DELETED_UNI=$((DELETED_UNI+DEL_COUNT));;
      esac

      eval "RET_${FOLDER}=\"deleted ${DEL_COUNT}, kept ${KEEP} of ${COUNT}\""
      add "Retention: ${FOLDER}/ deleted ${DEL_COUNT}, kept ${KEEP} of ${COUNT}"
    }

    prune_folder "pfsense"  "$RETAIN"
    prune_folder "truenas"  "$RETAIN"
    prune_folder "unifi"    "$RETAIN"
    add "Pruned totals -> pfsense:${DELETED_PFS} truenas:${DELETED_TRU} unifi:${DELETED_UNI}"
